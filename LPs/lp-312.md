---
lp: 312
title: SLH-DSA Signature Verification Precompile
description: Native precompile for NIST FIPS 205 SLH-DSA (SPHINCS+) hash-based post-quantum signatures
author: Lux Core Team (@luxfi)
discussions-to: https://github.com/luxfi/lps/discussions
status: Draft
type: Standards Track
category: Core
created: 2025-11-13
requires: 4, 311
activation:
  flag: lp312-slhdsa-precompile
  hfName: "Quantum"
  activationHeight: "0"
---

## Abstract

This LP specifies a precompiled contract for verifying SLH-DSA (Stateless Hash-based Digital Signature Algorithm) signatures as standardized in NIST FIPS 205. The precompile implements SLH-DSA-192s (security level 3, small variant) verification at address `0x0200000000000000000000000000000000000007`, providing stateless hash-based quantum-resistant signatures with ~15ms verification performance.

## Motivation

SLH-DSA (formerly SPHINCS+) provides unique security properties compared to ML-DSA:

1. **Hash-based security**: Security relies only on hash function collision resistance, not structured lattice problems
2. **Conservative security**: More conservative post-quantum assumption than lattice-based schemes
3. **Stateless**: No state management required (unlike legacy hash-based schemes like XMSS)
4. **Long-term confidence**: Hash functions have decades of cryptanalytic history
5. **Backup option**: Provides alternative to ML-DSA if lattice problems are broken

### Use Cases

- **Ultra-long-term archives**: Documents meant to remain secure for 50+ years
- **Diversified security**: Use alongside ML-DSA for defense-in-depth
- **Conservative applications**: When lattice security is questioned
- **Audit trails**: Permanent, hash-based signatures for compliance

## Specification

### Precompile Address

```
0x0200000000000000000000000000000000000007
```

### Input Format

| Offset | Length | Field | Description |
|--------|--------|-------|-------------|
| 0      | 48     | `publicKey` | SLH-DSA-192s public key |
| 48     | 32     | `messageLength` | Message length as big-endian uint256 |
| 80     | 16224  | `signature` | SLH-DSA-192s signature |
| 16304  | variable | `message` | Message to verify |

**Total minimum size**: 16304 bytes (without message)

### Output Format

32-byte word:
- `0x...0001` - signature valid
- `0x...0000` - signature invalid

### Gas Cost

```
gas = BASE_COST + (messageLength * PER_BYTE_COST)

Where:
  BASE_COST = 500,000 gas (higher due to 15ms verification time)
  PER_BYTE_COST = 50 gas (higher due to multiple hash operations)
```

### Solidity Interface

```solidity
interface ISLHDSA {
    /**
     * @dev Verifies an SLH-DSA-192s signature
     * @param publicKey The 48-byte SLH-DSA-192s public key
     * @param message The message that was signed
     * @param signature The 16224-byte SLH-DSA-192s signature
     * @return valid True if signature is valid
     */
    function verify(
        bytes calldata publicKey,
        bytes calldata message,
        bytes calldata signature
    ) external view returns (bool valid);
}
```

## Rationale

### Why SLH-DSA-192s?

SLH-DSA variants:
- **128s/128f**: Level 1 (128-bit) - Small/Fast
- **192s/192f**: Level 3 (192-bit) - **Recommended** - Balanced
- **256s/256f**: Level 5 (256-bit) - Maximum security

We chose 192s (small, not fast) because:
1. NIST level 3 matches our ML-DSA choice
2. "Small" variant has smaller signatures (16KB vs 35KB for 192f)
3. Verification time difference is minimal (15ms vs 12ms)
4. Signature size is more important than signing speed for blockchain use

### Gas Cost Justification

- **Verification time**: ~15ms on Apple M1
- **Compared to ML-DSA**: 139x slower (15ms vs 108Î¼s)
- **Base cost**: ML-DSA is 100K gas, so 500K is 5x (conservative multiplier)
- **Per-byte cost**: 50 gas/byte due to multiple SHAKE-256 hashes

### Why Both ML-DSA and SLH-DSA?

Having both provides:
1. **Algorithm diversity**: If lattices are broken, hash-based still works
2. **Different trust assumptions**: Lattices vs hash functions
3. **Use case optimization**: ML-DSA for speed, SLH-DSA for conservatism
4. **Hybrid schemes**: Can require both for maximum security

## Security Considerations

### Hash-Based Security

SLH-DSA security depends solely on:
- **SHAKE-256** collision resistance
- **No structured problems** (unlike lattices)
- **Post-quantum proven** security reductions

### Signature Size Trade-off

Large signatures (16KB) may impact:
- Transaction size limits
- Storage costs
- Bandwidth requirements

Mitigation: Use SLH-DSA selectively for high-value operations only.

### Performance Impact

15ms verification is 139x slower than ML-DSA:
- Use for critical operations where conservatism is needed
- Batch verifications where possible
- Consider async verification for UX

## Reference Implementation

See: `standard/src/precompiles/slhdsa/` (to be implemented)

## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
