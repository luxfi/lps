---
lp: 326
title: Blockchain Regenesis and State Migration
description: Standard procedure for exporting chain state and creating new genesis files for network upgrades
author: Lux Core Team (@luxfi)
discussions-to: https://github.com/luxfi/lps/discussions
status: Active
type: Standards Track
category: Core
created: 2025-11-22
requires: 181
---

## Abstract

This LP specifies the standard procedure for blockchain regenesisâ€”the process of exporting the complete state of a running blockchain and importing it as the genesis state of a new network. Regenesis enables major network upgrades, chain consolidation, and architecture migrations while preserving all account balances, smart contract storage, and deployed code.

## Motivation

### Why Regenesis is Necessary

Blockchain networks occasionally require fundamental changes that cannot be accomplished through standard upgrades:

1. **Architecture Migration**: Moving from one consensus mechanism to another (e.g., Avalanche Consensus â†’ Lux Consensus)
2. **Chain Consolidation**: Merging multiple chains into a unified architecture
3. **State Cleanup**: Removing obsolete data and optimizing storage
4. **Protocol Breaking Changes**: Implementing incompatible improvements
5. **Multi-Chain Expansion**: Splitting a single chain into specialized chains (A, B, C, D, Y, Z chains)

### The Lux Initial 4-Chain Launch

Lux Network launches with 4 primary chains, with additional specialized chains planned for future expansion:

| Chain | Purpose | VM Type | Status |
|-------|---------|---------|--------|
| **P-Chain** | Platform/Validators | Linear Consensus | âœ… Launch |
| **C-Chain** | EVM Smart Contracts | BFT Consensus | âœ… Launch |
| **X-Chain** | Asset Exchange | DAG Consensus | âœ… Launch |
| **Q-Chain** | Quantum-Resistant Operations | Hybrid PQ Consensus | âœ… Launch |
| **B-Chain** | Cross-Chain Bridges | Bridge VM | ğŸ”„ Planned |
| **Z-Chain** | Zero-Knowledge Proofs | ZK VM | ğŸ”„ Planned |
| **M-Chain** | TBD | TBD | ğŸ”„ Planned |

Initial regenesis preserves:
- All account balances across all chains
- All deployed smart contracts and their storage
- All staking records and validator history
- All transaction history (via separate archive)

## Specification

### Regenesis Process Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Running Chain  â”‚
â”‚   (Old State)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ 1. Export State
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  State Export   â”‚
â”‚ (Database Dump) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ 2. Convert to Genesis
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Genesis File   â”‚
â”‚    (JSON)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ 3. Initialize New Chain
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   New Chain     â”‚
â”‚  (New State)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Phase 1: State Export

#### 1.1 Export Chain State from Database

Use the `export-state-to-genesis` tool to extract all state from the blockchain database:

```bash
# Export state from PebbleDB/BadgerDB
cd /Users/z/work/lux/state/scripts
go run export-state-to-genesis.go \
  /path/to/chaindata \
  /output/genesis-export.json
```

**What Gets Exported**:
- Account balances (all addresses with non-zero balance)
- Account nonces
- Smart contract bytecode
- Contract storage (all non-zero storage slots)
- Total supply verification

#### 1.2 Export Block History (Optional)

For historical reference and verification:

```go
// Export blocks 0 through N
blockchain.ExportN(writer, 0, lastBlockNumber)

// Or export with custom callback
blockchain.ExportCallback(func(block *types.Block) error {
    // Process each block
    return archiveBlock(block)
}, 0, lastBlockNumber)
```

### Phase 2: Genesis File Creation

#### 2.1 Genesis File Structure

```json
{
  "config": {
    "chainId": 96369,
    "homesteadBlock": 0,
    "eip150Block": 0,
    "eip155Block": 0,
    "eip158Block": 0,
    "byzantiumBlock": 0,
    "constantinopleBlock": 0,
    "petersburgBlock": 0,
    "istanbulBlock": 0,
    "berlinBlock": 0,
    "londonBlock": 0,
    "shanghaiBlock": 0,
    "terminalTotalDifficulty": "0x0",
    "terminalTotalDifficultyPassed": true
  },
  "nonce": "0x0",
  "timestamp": "0x0",
  "extraData": "0x00",
  "gasLimit": "0x7a1200",
  "difficulty": "0x0",
  "mixhash": "0x0000000000000000000000000000000000000000000000000000000000000000",
  "coinbase": "0x0000000000000000000000000000000000000000",
  "alloc": {
    "0x1234...": {
      "balance": "0x...",
      "nonce": 42,
      "code": "0x...",
      "storage": {
        "0x0": "0x...",
        "0x1": "0x..."
      }
    }
  }
}
```

#### 2.2 State Verification

Before using exported genesis:

```bash
# Verify total balance matches
total_exported=$(jq '[.alloc | to_entries[].value.balance |
  ltrimstr("0x") | tonumber] | add' genesis-export.json)

# Verify account count
account_count=$(jq '.alloc | length' genesis-export.json)

# Verify contract count
contract_count=$(jq '[.alloc | to_entries[] |
  select(.value.code != null and .value.code != "0x")] |
  length' genesis-export.json)

echo "Total Balance: $total_exported"
echo "Accounts: $account_count"
echo "Contracts: $contract_count"
```

### Phase 3: Network Initialization

#### 3.1 Initialize New Network

```bash
# Initialize geth with new genesis
geth init /path/to/genesis-export.json \
  --datadir /path/to/new/datadir

# Verify initialization
geth --datadir /path/to/new/datadir \
  console \
  --exec "eth.getBlock(0)"
```

#### 3.2 Start Network

```bash
# Start first bootstrap node
geth --datadir /path/to/new/datadir \
  --networkid 96369 \
  --http \
  --http.api eth,net,web3 \
  --bootnodes "" \
  console
```

#### 3.3 Validator Migration

For P-Chain (Platform) validators:

```go
// Export validator set from old chain
oldValidators := oldDChain.GetCurrentValidators()

// Create validator entries in new genesis
for _, v := range oldValidators {
    newGenesis.Validators = append(newGenesis.Validators, Validator{
        NodeID:    v.NodeID,
        PublicKey: v.BLSPublicKey,
        Weight:    v.Weight,
        StartTime: newGenesisTime,
        EndTime:   v.EndTime,
    })
}
```

## Implementation

### Export State Tool

Location: `/Users/z/work/lux/state/scripts/export-state-to-genesis.go`

**Features**:
- Reads from PebbleDB/BadgerDB database
- Extracts accounts, code, and storage
- Skips zero-balance accounts (optional)
- Validates total supply
- Outputs compliant genesis JSON

**Usage**:
```bash
go run export-state-to-genesis.go <db-path> <output-genesis.json>
```

**Output Statistics**:
```
=== Exporting state from /data/chaindata ===
Found:
  Accounts: 42,573
  Contract codes: 8,291
  Storage entries: 156,842

Total balance across all accounts: 1,000,000,000,000,000,000
Genesis alloc contains 42,573 accounts

Wrote genesis to /output/genesis-export.json
```

### Blockchain Export APIs

Location: `/Users/z/work/lux/evm/core/blockchain.go`

```go
// Export entire blockchain
func (bc *BlockChain) Export(w io.Writer) error

// Export block range
func (bc *BlockChain) ExportN(w io.Writer, first uint64, last uint64) error

// Export with custom processing
func (bc *BlockChain) ExportCallback(
    callback func(block *types.Block) error,
    first uint64,
    last uint64,
) error
```

**Example: Export blocks to archive**:
```go
f, _ := os.Create("blocks-archive.rlp")
defer f.Close()

blockchain.ExportN(f, 0, blockchain.CurrentBlock().NumberU64())
```

## Integration with LP-181 (Epoching)

Regenesis respects epoch boundaries from LP-181:

### Epoch-Aligned Regenesis

```go
// Get current epoch
currentEpoch := proposerVM.GetCurrentEpoch()

// Wait until epoch seals
for !isEpochSealed(currentEpoch) {
    time.Sleep(1 * time.Second)
}

// Export state at exact epoch boundary
exportStateAtHeight(currentEpoch.DChainHeight)
```

**Benefits**:
1. **Validator Set Consistency**: All chains reference same P-Chain epoch
2. **Cross-Chain Sync**: All 4 chains regenesis at same epoch (P, C, X, Q)
3. **Predictable Timing**: Known in advance when regenesis will occur

### Multi-Chain Regenesis Coordination

For the initial 4-chain architecture (with future expansion to B, Z, M):

```go
type RegensisCoordinator struct {
    chains map[string]*Chain // P, C, X, Q (+ B, Z, M future)
    targetEpoch uint64
}

func (rc *RegensisCoordinator) ExportAllChainsAtEpoch(epoch uint64) error {
    // Wait for target epoch to seal
    <-rc.waitForEpochSeal(epoch)

    // Export all active chains simultaneously (P, C, X, Q)
    var wg sync.WaitGroup
    for chainID, chain := range rc.chains {
        wg.Add(1)
        go func(id string, c *Chain) {
            defer wg.Done()
            c.ExportStateAtEpoch(epoch)
        }(chainID, chain)
    }
    wg.Wait()

    // Verify all exports match epoch height
    return rc.verifyExports(epoch)
}
```

## Security Considerations

### State Integrity

1. **Hash Verification**: Export must preserve state root hash
2. **Balance Conservation**: Total supply must match exactly
3. **Contract Code**: Bytecode must be identical
4. **Storage Proofs**: Critical contracts should have Merkle proofs

### Validator Coordination

1. **BLS Keys**: Validator signing keys must be migrated securely
2. **Staking Records**: All staking history must be preserved
3. **Delegation**: Delegator balances and relationships maintained
4. **Slashing**: Any pending slashing conditions must be resolved

### Timestamp Management

```go
// New genesis timestamp should be slightly in future
newGenesisTime := time.Now().Add(24 * time.Hour)

// But not too far (validator certificates expire)
if newGenesisTime.Sub(oldFinalBlock.Time) > 30*24*time.Hour {
    return ErrTimestampTooFar
}
```

### Quantum-Safe Migration (Q-Chain)

Q-Chain includes quantum-resistant operations from launch:

1. **Export Quantum State**: Include Q-Chain quantum-resistant transaction data
2. **Validator Signatures**: Support both classical BLS and post-quantum ML-DSA
3. **Verify Quantum Proofs**: Ensure quantum-resistant signatures validate in new chain

**Note**: B-Chain, Z-Chain, and M-Chain quantum integration will be addressed in future regenesis specifications.

## Testing

### Pre-Production Testing

```bash
# 1. Export mainnet state
go run export-state-to-genesis.go \
  /mainnet/chaindata \
  /test/mainnet-genesis.json

# 2. Initialize test network
geth init /test/mainnet-genesis.json \
  --datadir /test/datadir

# 3. Start test node
geth --datadir /test/datadir \
  --networkid 99999 \
  console

# 4. Verify state
> eth.getBalance("0x...")  // Check known addresses
> eth.getCode("0x...")     // Verify contract code
> debug.trieHash()         // Compare state root
```

### Regenesis Checklist

**Initial 4-Chain Launch**:
- [ ] Export state from all chains (P, C, X, Q)
- [ ] Verify total balance conservation
- [ ] Verify contract count matches
- [ ] Export block history to archive
- [ ] Generate new genesis files
- [ ] Test genesis initialization on devnet
- [ ] Verify state root matches
- [ ] Coordinate validator migration
- [ ] Update network parameters (chain ID, timestamps)
- [ ] Test cross-chain communication
- [ ] Perform load testing
- [ ] Prepare rollback plan
- [ ] Schedule maintenance window
- [ ] Notify community and exchanges
- [ ] Execute production regenesis
- [ ] Monitor network health post-regenesis

**Future Chain Expansion** (B, Z, M):
- [ ] Design chain-specific regenesis procedures
- [ ] Plan migration timeline
- [ ] Community governance approval

## Backwards Compatibility

Regenesis is **not backwards compatible**. It creates a new network with new genesis.

### Migration Path

1. **Announce Freeze Block**: Community agrees on final block height
2. **Export Window**: 24-48 hour export and verification period
3. **Network Launch**: New network starts with exported genesis
4. **Dual Operation** (Optional): Old network remains as archive for 30-90 days
5. **Canonical Transition**: New network becomes primary after stability period

### Archive Node Requirements

Maintain archive nodes for old network:
- Transaction history lookups
- Historical state queries
- Audit and compliance
- Legal requirements

## Operational Procedures

### Emergency Regenesis

In case of critical bug or security incident:

```bash
# 1. Halt network immediately
curl -X POST http://localhost:9650/ext/admin \
  -H 'Content-Type: application/json' \
  -d '{"jsonrpc":"2.0","id":1,"method":"admin.lockProfile"}'

# 2. Export state BEFORE bug impact
go run export-state-to-genesis.go \
  /data/chaindata \
  /backup/pre-incident-genesis.json \
  --max-height=$LAST_GOOD_BLOCK

# 3. Create patched node binary
make build-patched

# 4. Test regenesis on isolated network
./test-regenesis.sh

# 5. Coordinate validator upgrade
# 6. Launch new network
```

### Performance Optimization

For large state exports (>100GB):

```go
// Parallel export by address range
func ExportByRange(dbPath string, startAddr, endAddr common.Address) {
    db := openDB(dbPath)

    iter := db.NewIterator(pebble.IterOptions{
        LowerBound: startAddr.Bytes(),
        UpperBound: endAddr.Bytes(),
    })
    defer iter.Close()

    // Process in chunks
    batchSize := 10000
    batch := make([]Account, 0, batchSize)

    for iter.First(); iter.Valid(); iter.Next() {
        acc := decodeAccount(iter.Value())
        batch = append(batch, acc)

        if len(batch) >= batchSize {
            writeBatch(batch)
            batch = batch[:0]
        }
    }
}
```

## Future Enhancements

### Incremental Regenesis

Instead of full state export, export only changes:

```go
type IncrementalExport struct {
    BaseGenesis    string      // Previous genesis hash
    ModifiedAccounts []Account  // Changed accounts only
    NewContracts   []Contract  // Newly deployed contracts
    UpdatedStorage []Storage   // Modified storage
}
```

### Cross-Chain State Proofs

Verify state consistency across all 6 chains:

```go
type CrossChainStateProof struct {
    AChain common.Hash
    BChain common.Hash
    CChain common.Hash
    DChain common.Hash
    YChain common.Hash
    ZChain common.Hash
    Timestamp time.Time
    ProofOfConsistency []byte
}
```

### Automatic Regenesis

Scheduled regenesis for regular maintenance:

```go
const RegenesisInterval = 365 * 24 * time.Hour // Annual

func (n *Network) CheckRegenesisSchedule() {
    if time.Since(n.GenesisTime) > RegenesisInterval {
        n.ProposeRegenesis()
    }
}
```

## References

1. [LP-181: P-Chain Epoched Views](lp-181-epoching.md)
2. [Lux State Package](https://github.com/luxfi/state)
3. [Geth Genesis Format](https://geth.ethereum.org/docs/fundamentals/private-network)
4. [PebbleDB Documentation](https://github.com/cockroachdb/pebble)

## Tools

- **export-state-to-genesis**: `/Users/z/work/lux/state/scripts/export-state-to-genesis.go`
- **Blockchain Export API**: `/Users/z/work/lux/evm/core/blockchain.go`
- **Genesis Validation**: `/Users/z/work/lux/evm/core/genesis.go`

## Acknowledgements

Based on Ethereum's genesis format and Avalanche's subnet migration patterns. Special thanks to the Lux Core Team for implementing the 4-chain initial architecture (P, C, X, Q) with future expansion plans for B, Z, and M chains.

## Copyright

Copyright Â© 2025 Lux Industries Inc. All rights reserved.
